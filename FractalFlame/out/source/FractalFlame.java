/* autogenerated by Processing revision 1292 on 2023-06-19 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class FractalFlame extends PApplet {

PVector current;
Variation finalV;

ArrayList<Variation> variations = new ArrayList<Variation>();

Pixel[][] pixies;
PImage flameImg;

int total = 10000000;
int perFrame = 500000;
int count = 0;

// From: https://github.com/scottdraves/flam3/blob/master/test.flam3
//<xform weight="0.25" color="1" spherical="1" coefs="-0.681206 -0.0779465 0.20769 0.755065 -0.0416126 -0.262334"/>
//<xform weight="0.25" color="0.66" spherical="1" coefs="0.953766 0.48396 0.43268 -0.0542476 0.642503 -0.995898"/>
//<xform weight="0.25" color="0.33" spherical="1" coefs="0.840613 -0.816191 0.318971 -0.430402 0.905589 0.909402"/>
//<xform weight="0.25" color="0" spherical="1" coefs="0.960492 -0.466555 0.215383 -0.727377 -0.126074 0.253509"/>

//<xform weight="0.25" color="1" spherical="1" coefs="-0.357523 0.774667 0.397446 0.674359 -0.730708 0.812876"/>
//<xform weight="0.25" color="0.66" spherical="1" coefs="-0.69942 0.141688 -0.743472 0.475451 -0.336206 0.0958816"/>
//<xform weight="0.25" color="0.33" spherical="1" coefs="0.0738451 -0.349212 -0.635205 0.262572 -0.398985 -0.736904"/>
//<xform weight="0.25" color="0" spherical="1" coefs="0.992697 0.433488 -0.427202 -0.339112 -0.507145 0.120765"/>

int c1, c2;
public void setup() {
  /* size commented out by preprocessor */;

  // Pick two colors
  c1 = randomColor();
  c2 = randomColor();
  // Make sure they aren't the same
  while (c1 == c2) {
    c2 = randomColor();
  }

  // Four hard-coded variations
  Variation s1 = new Spherical().setColor(1);
  s1.setTransform(new float[]{-0.681206f, -0.0779465f, 0.20769f, 0.755065f, -0.0416126f, -0.262334f});
  Variation s2 = new Spherical().setColor(0.66f);
  s2.setTransform(new float[]{0.953766f, 0.48396f, 0.43268f, -0.0542476f, 0.642503f, -0.995898f});
  Variation s3 = new Spherical().setColor(0.33f);
  s3.setTransform(new float[]{0.840613f, -0.816191f, 0.318971f, -0.430402f, 0.905589f, 0.909402f});
  Variation s4 = new Spherical().setColor(0);
  s4.setTransform(new float[]{0.960492f, -0.466555f, 0.215383f, -0.727377f, -0.126074f, 0.253509f});

  variations.add(s1);
  variations.add(s2);
  variations.add(s3);
  variations.add(s4);

  // pixel map and image
  pixies = new Pixel[width][height];
  for (int i = 0; i < width; i++) {
    for (int j = 0; j < height; j++) {
      pixies[i][j] = new Pixel();
    }
  }
  flameImg = createImage(width, height, RGB);

  //variations.add(new Linear(1));
  //variations.add(new Sinusoidal());
  //variations.add(new Swirl());
  //variations.add(new Spherical());
  //variations.add(new HorseShoe());
  //variations.add(new Polar());
  //variations.add(new Hankerchief());
  //variations.add(new Heart());
  //variations.add(new Disc());
  variations.add(new Hyperbolic());
  //variations.add(new Fisheye());

  // Starting point
  current  = new PVector();
  // Random xy
  current.x = random(-1, 1);
  current.y = random(-1, 1);
  // Using z for "c" (color)
  current.z = random(0, 1);
}

public void draw() {

  // Iterations per frame
  for (int i = 0; i < perFrame; i++) {
    // Pick a variation (equal probabilities)
    int index = PApplet.parseInt(random(variations.size()));
    Variation variation = variations.get(9);
    // Save previous point just in case
    PVector previous = current.copy();
    
    // New point
    current = variation.flame(current);

    // If we end up in some divide by zero disaster land go back to previous point
    if (Float.isNaN(current.x) || Float.isNaN(current.y) || !Float.isFinite(current.x) || !Float.isFinite(current.y)) {
      current = previous.copy();
    }
    
    // Silly double-checking
    if (Float.isNaN(current.x) || Float.isNaN(current.y) || !Float.isFinite(current.x) || !Float.isFinite(current.y)) {
      println("problem!");
    }


    // A final transformation to fit on window
    float zoom = 0.5f;
    float x = current.x * width * zoom;
    float y = -1*current.y * height * zoom;
    
    // Pixel location
    int px = PApplet.parseInt(x + width/2);
    int py = PApplet.parseInt(y + height/2);
    
    // Are we in the window?
    if (px >= 0 && px < width && py >= 0 && py < height) {
      // Increase count
      pixies[px][py].value++;
      // Pick color
      int c = lerpColor(c1, c2, current.z);
      // Increase rgb counters
      pixies[px][py].r += red(c) / 255;
      pixies[px][py].g += green(c) / 255;
      pixies[px][py].b += blue(c) / 255;
    }
  }

  // Find maximum
  float max = 0;
  for (int i = 0; i < width; i++) {
    for (int j = 0; j < height; j++) {
      Pixel pix = pixies[i][j];
      float value = (float) Math.log10(pix.value);
      max = max(max, value);
    }
  }
  
  // Set all pixels
  flameImg.loadPixels();
  for (int i = 0; i < width; i++) {
    for (int j = 0; j < height; j++) {
      Pixel pix = pixies[i][j];
      float value = (float) Math.log10(pix.value)/max;
      int index = i + j * width;
      float r = pix.r * value;
      float g = pix.g * value;
      float b = pix.b * value;
      
      // Apply gamma
      float gamma = 1 / 4.0f;
      r = 255 * pow((r/255), gamma);
      g = 255 * pow((g/255), gamma);
      b = 255 * pow((b/255), gamma);

      flameImg.pixels[index] = color(r, g, b);
    }
  }
  flameImg.updatePixels();
  
  // Draw image
  background(0);
  image(flameImg, 0, 0);
  
  // Check progress
  count += perFrame;
  if (count < total) {
    float percent = PApplet.parseFloat(count) / total;
    fill(255);
    rect(0, 50, percent * width, 50);
  } else {
    noLoop();
    saveFrame("render"+millis()+".png");
  }
}
int[] palette ={ 
  color(11, 106, 136), 
  color(45, 197, 244), 
  color(11, 106, 136), 
  color(112, 50, 126), 
  color(146, 83, 161), 
  color(164, 41, 99), 
  color(236, 1, 90), 
  color(240, 99, 164), 
  color(241, 97, 100), 
  color(248, 158, 79), 
  color(252, 238, 33)  
};

public int randomColor() {
  int i = floor(random(palette.length));
  return palette[i];
}
class Pixel {
  float value;
  float r, g, b;

  Pixel() {
    value = 0;
    r = g = b = 0;
  }
}
class Variation {
  float[] preTransform = new float[6];
  float[] postTransform = new float[6];
  float colorVal;
  String name;

  public Variation setColor(float val) {
    colorVal = val;
    return this;
  }

  public Variation setTransform(float[] pre) {
    this.preTransform = pre;
    return this;
  }

  Variation() {
    for (int i = 0; i < 6; i++) {
      this.preTransform[i] = random(-1, 1);
      this.postTransform[i] = random(-1, 1);
    }
  }

  public PVector affine(PVector v, float[] coeff) {
    float x = coeff[0] * v.x + coeff[1] * v.y + coeff[2];
    float y = coeff[3] * v.x + coeff[4] * v.y + coeff[5];
    return new PVector(x, y);
  }

  public PVector f(PVector v) {
    return v.copy();
  }

  public PVector flame(PVector input) {
    // Pre transform
    PVector v = this.affine(input, this.preTransform);

    // Apply variation
    v = this.f(v);

    // Color averages
    v.z = (input.z + colorVal) * 0.5f;

    // Skipping post transform for testing
    // v = this.affine(v, this.postTransform);
    return v;
  }
}

class Fisheye extends Variation {    
  Fisheye() {
    super();
    this.name = "Fisheye";
  }

  public PVector f(PVector v) {
    float r = v.x * v.x + v.y * v.y;
    PVector newV = new PVector(v.y, v.x);
    newV.mult(2 / (r+1));
    return newV;
  }
}

class Diamond extends Variation {    
  Diamond() {
    super();
    this.name = "Diamond";
  }

  public PVector f(PVector v) {
    float r = v.x * v.x + v.y * v.y;
    float theta = atan(v.x / v.y);
    float x =  sin(theta) * cos(r);
    float y =  cos(theta) * sin(r);
    return new PVector(x, y);
  }
}

class Hyperbolic extends Variation {    
  Hyperbolic() {
    super();
    this.name = "Hyperbolic";
  }

  public PVector f(PVector v) {
    float r = v.x * v.x + v.y * v.y;
    float theta = atan(v.x / v.y);
    float x =  sin(theta) / r;
    float y =  r * cos(theta);
    return new PVector(x, y);
  }
}

class Spiral extends Variation {    
  Spiral() {
    super();
    this.name = "Spiral";
  }

  public PVector f(PVector v) {
    float r = v.x * v.x + v.y * v.y;
    float theta = atan(v.x / v.y);
    float x =  (1/r) * (cos(theta) + sin(r));
    float y =  (1/r) * (sin(theta) - cos(r));
    return new PVector(x, y);
  }
}


class Disc extends Variation {    
  Disc() {
    super();
    this.name = "Disc";
  }

  public PVector f(PVector v) {
    float r = v.x * v.x + v.y * v.y;
    float theta = atan(v.x / v.y);
    float x =  (theta/PI) * sin(PI * r);
    float y =  (theta/PI) * cos(PI * r);
    return new PVector(x, y);
  }
}

class Heart extends Variation {    
  Heart() {
    super();
    this.name = "Heart";
  }

  public PVector f(PVector v) {
    float r = v.x * v.x + v.y * v.y;
    float theta = atan(v.x / v.y);
    float x =  r * sin(theta * r);
    float y = -r * cos(theta * r);
    return new PVector(x, y);
  }
}


class Hankerchief extends Variation {    
  Hankerchief() {
    super();
    this.name = "Hankerchief";
  }

  public PVector f(PVector v) {
    float r = v.x * v.x + v.y * v.y;
    float theta = atan(v.x / v.y);
    float x = r * sin(theta + r);
    float y = r * cos(theta - r);
    return new PVector(x, y);
  }
}

class Polar extends Variation {    
  Polar() {
    super();
    this.name = "Polar";
  }

  public PVector f(PVector v) {
    float r = v.x * v.x + v.y * v.y;
    float theta = atan(v.x / v.y);
    float x = theta / PI;
    float y = r - 1;
    return new PVector(x, y);
  }
}


class HorseShoe extends Variation {    
  HorseShoe() {
    super();
    this.name = "HorseShoe";
  }

  public PVector f(PVector v) {
    float r = v.x * v.x + v.y * v.y;
    float x = (v.x - v.y) * (v.x + v.y);
    float y = 2 * v.x * v.y;
    return new PVector(x / r, y / r);
  }
}

class Spherical extends Variation {
  Spherical() {
    super();
    this.name = "Spherical";
  }

  public PVector f(PVector v) {
    float r = v.x*v.x + v.y*v.y;
    return new PVector(v.x / r, v.y / r);
  }
}


class Swirl extends Variation {
  Swirl() {
    super();
    this.name = "Swirl";
  }

  public PVector f(PVector v) {
    float r = v.magSq();
    return new PVector(v.x * sin(r) - v.y * cos(r), v.x * cos(r) - v.y * sin(r));
  }
}


class Sinusoidal extends Variation {
  Sinusoidal() {
    super();
    this.name = "Sinusoidal";
  }

  public PVector f(PVector v) {
    return new PVector(sin(v.x), sin(v.y));
  }
}


class Linear extends Variation {
  float amt;

  Linear(float amt) {
    super();
    this.amt = amt;
  }

  public PVector f(PVector v) {
    return new PVector(v.x * amt, v.y * amt);
  }
}


  public void settings() { size(640, 480); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "FractalFlame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
